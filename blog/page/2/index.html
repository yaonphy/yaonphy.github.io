<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>yaongfeng</title>
  <meta name="author" content="yaongfeng">

  
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yaonphy.github.io/blog/page/2">
  <link href="/favicon.png" type="image/png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="yaongfeng" type="application/atom+xml">

  <link href="/assets/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet" type="text/css">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">

  <script src="/javascripts/libs/jquery/jquery-2.0.3.min.js"></script>
  

</head>

  <body   >
    <div id="wrap">
      <header role="banner">
        <nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">yaongfeng</a>
        </div>

        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li class="active">
                    <a href="/">Blog</a>
                </li>
                <li >
                    <a href="/blog/archives">Archives</a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a class="subscribe-rss" href="/atom.xml" title="subscribe via RSS">
                        <span class="visible-xs">RSS</span>
                        <img class="hidden-xs" src="/images/rss.png" alt="RSS">
                    </a>
                </li>
                
            </ul>
            
                <form class="search navbar-form navbar-right" action="http://google.com/search" method="GET">
                    <input type="hidden" name="q" value="site:yaonphy.github.io">
                    <div class="form-group">
                        <input class="form-control" type="text" name="q" placeholder="Search">
                    </div>
                </form>
            
        </div>
    </div>
</nav>


      </header>
      <div id="main" class="container">
        <div id="content">
          <div class="row">
  <div class="page-content col-md-9">
    <div class="blog-index">
      
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-04-22T16:10:41+08:00" pubdate data-updated="true">Apr 22<span>nd</span>, 2014</time>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2014/04/22/clone-a-octopress-to-new-places/">在新的环境（电脑）配置已有的 Octopress 博客</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p>于2014.04.14在苹果官方商城下单，预定了第一台属于自己的 Mac 电脑。内心自然是非常喜欢 MBA 的，也算是实现了近期的一个愿望。之前用过非Retina的15英寸 MBP，毕竟是配备的，不是自己的，感觉是完全不一样的（是不是有点偏执^_^）。离开的时候还得留下设备，细心点的话，还需要清空下浏览器的cookie啦，保留的密码啦，浏览历史记录啦等等个人信息。如果是个好人，还会清理掉其它所有自己认为不应该留给第二个机主看到的东西。拿到新的配备机后，重新配置环境，设置自己的喜好风格，太麻烦！</p>

<p>再三纠结之后，选择了 i7 8G内存 128G闪存的配置，官网价格约9500人民币，使用教育优惠渠道（随机抽查（偷笑））购买约9000人民币。历经4天后，于4.18日下午到手，组装地在上海南汇，EMS的快递一般吧。</p>

<hr />

<h2>安装 Homebrew（可选）</h2>

<p>由于后续操作依赖于Homebrew，所以必须要装的。可以按照 Homebrew <a href="http://brew.sh/">官网的说明</a>来安装。需要注意的是，最好将网络DNS设置为Google的8.8.8.8 DNS 服务，否则拉不下来数据，我是新机子，还没来得及设置 DNS ，试了好几次，下载都中断了。。。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>ruby -e <span class="s2">&quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>安装 Ruby 的相关工具（可选）</h2>

<p>如果你的机器中已经安装好了下面的工具，请忽略。</p>

<h3>安装RVM</h3>

<p>RVM可以方便的管理 Ruby 的各个版本，在 Terminal 输入下面的命令即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>curl -L https://get.rvm.io | bash -s stable --ruby
</span></code></pre></td></tr></table></div></figure>


<h3>安装 bundle</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>gem install bundler
</span><span class='line'>bundle install
</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>确保 remote 端的 repository 中 source 分支是最新的</h2>

<p>在老机器（老环境中），如果一直使用 rake deploy 命令来 push 生成的 blog 资源到远程 repository 中，更新的只是 master 分支。看一下本地 source 分支（即 Octopress 根目录）中的内容是否和远程 source 分支中的内容同步，若不是，在老机器中，用下面的命令来 push 下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#切换到 Octopress 目录下</span>
</span><span class='line'><span class="nv">$ </span>rake generate
</span><span class='line'><span class="nv">$ </span>git add --a
</span><span class='line'><span class="nv">$ </span>git commit -a <span class="s2">&quot;Some comment here.&quot;</span>
</span><span class='line'><span class="nv">$ </span>git push origin <span class="nb">source</span>  <span class="c"># update the remote source branch</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>在新环境中拉取 source 分支资源</h2>

<p>在你想要的地方，将远程 source 分支拉取到 Octopress 目录，将 repository 地址更换为自己的而已。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>git clone -b <span class="nb">source </span>https://github.com/username/username.github.io.git Octopress
</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>在新环境中拉取 master 分支资源</h2>

<p>紧接着上一步，进入 Octopress 目录（随意），将远程 repository 中的 master 分支拉取到 _deploy 目录中，将 repository 地址更换为自己的而已</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span><span class="nb">cd </span>Octopress
</span><span class='line'><span class="nv">$ </span>git clone -b master https://github.com/username/username.github.io.git _deploy
</span></code></pre></td></tr></table></div></figure>


<hr />

<h2>完成</h2>

<p>好了，现在可以在新环境下，使用 rake generate 和 rake preview 命令来生成和本地查看 blog 了。如果有在两个环境下同时更新博客的需求，就要像多人协作开发那样，提交更新前，需要先拉取远程资源，合并后再 push，以保持一致。</p>

<hr />

<h2>参考</h2>

<ul>
<li><a href="http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/">Clone Your Octopress to Blog From Two Places</a></li>
<li><a href="http://octopress.org/docs/">Octopress</a></li>
<li><a href="http://brew.sh/">Homebrew</a></li>
</ul>

</div>
  
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-04-03T17:51:49+08:00" pubdate data-updated="true">Apr 3<span>rd</span>, 2014</time>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2014/04/03/introducing-mknetworkkit/">iOS Framework: Introducing MKNetworkKit（简体中文翻译）</a></h1>
    
  </header>


  <div class="entry-content clearfix"><h4>文章的原版（英文原文）<a href="http://blog.mugunthkumar.com/products/ios-framework-introducing-mknetworkkit/">链接</a>，看到教程已经被翻译为<a href="http://science.webhostinggeeks.com/predstavljanje-mknetworkkit">塞尔维亚 – 克罗地亚语</a> by <a href="http://webhostinggeeks.com/">Jovana Milutinovich</a>，<a href="http://odoruinu.net/blog/mknetworkkit/">日语</a> by <a href="http://odoruinu.net/">@noradaiko</a>，<a href="http://blog.mugunthkumar.com/products/ios-framework-einfuhrung-in-mknetworkkit-german-translation-of-mknetworkkit-documentation/">德语</a> by <a href="https://twitter.com/jonaspencke">Jonas Pencke</a>。故而有了翻译为中文的念头。</h4>

<p>如果有一个网络库能够自动的帮你搞定缓存处理，那该是多么爽的一件事。当你的 App 的网络变为离线状态时，要是有一个网络库能够自动的保留未完成的网络操作，那简直爽歪歪的赶脚啊。</p>

<p>你在离线状态下，将某个Tweet 标记为喜欢，或者将某个推荐内容标记为已读。你不用额外多敲任何代码，网络库会在网络处于连接状态时自动完成所有的离线任务。让我们一起走进 MKNetworkKit。</p>

<hr />

<h2>MKNetwork 渊源</h2>

<p>MKNetwork 使用 Objective-C 编写，是一款与 apple 官方网络接口无缝对接，基于 block，支持 ARC，并且非常简单易用的网络库。编写MKNetwork 的灵感来源于 ASIHTTPRequest 和 AFNetworking 这两款非常流行的OC网络库。</p>

<p>在吸收这两款网络库的优秀功能的基础之上，MKNetwork 增加了一些新的功能。除此之外，相比于其他网络库，MKNetwork 能够让你写出更多清晰、简洁的代码。使用 MKNetwork，你就很难写出非常恶心的网络接口代码了。</p>

<hr />

<h2>功能</h2>

<h3>超轻量级</h3>

<p>这个kit由两个主要的类，以及一些 category(附加)方法组成。这意味着，使用 MKNetwork 是超简单的一件事。</p>

<p>为整个 App 提供单一共享的请求队列</p>

<p>基于大量网络请求的 apps 应当优化并发的网络请求操作。非常遗憾的是，目前没有一个网络库能够彻底的实现。如果你的应用程序没有优化/控制并发网络请求操作数，将会出现哪些问题呢？我下面一一举例说明。</p>

<p>假设你正在往服务器传送一批图片（color or batch）。对于某一个IP地址，大多数的移动网络(3G)不允许超过两个的并发 HTTP 请求。也就是说，在3G 网络环境下，你的移动设备不能开启多于两个的并发网络请求。在 <a href="http://zh.wikipedia.org/wiki/GSM%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%8E%87%E6%BC%94%E8%BF%9B">EDGE</a>（2.75G）网络环境下，情况更糟糕，很多情况下，你都不能建立多于一个的网络连接。在 Wifi 环境下，情况会好一些，并发网络请求的上限个数是6。由于移动设备会在不同的网络环境中使用，所以应当根据网络环境对网络请求数做出相应的限制。通常，移动设备更多的使用 3G 网络，也就是说，同时最多上传两张图片。然而，问题不是缓慢的上传速度。当你在一个 View（其他的View）中下载图片的缩略图，同时，上传图片的操作在后台运行。这样，真正的问题便出现了。如果你的App没能正确的控制网络连接队列中连接数的大小，缩略图的加载操作将会超时。这显然不是你想要的结果吧。遇到上述的情况，应该这样处理：提高下载缩略图的网络请求的优先级，或者等到上传图片的操作完成之后再加载缩略图。这就要求在整个 App 中始终保持单一的网络请求列。MKNetwork 自动的为其每一个实例对象提供单一共享的请求队列。尽管 MKNetwork 本身不是一个单例，共享的 queue 是。</p>

<h3>及时准确的显示网络活动指示图标</h3>

<p>有很多第三方库的类追踪网络请求个数，通过网络请求个数的加加减减来显示/隐藏网络活动指示图标。回归到单一共享队列的原则，通过监听（KVO）operationCount 属性，MKNetwork自动地显示/隐藏网络活动指示图标。作为一个 developer，你不再需要手动的控制网络活动指示图标，永远不需要。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="n">_sharedNetworkQueue</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="p">[</span><span class="n">keyPath</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;operationCount&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">].</span><span class="n">networkActivityIndicatorVisible</span> <span class="o">=</span>
</span><span class='line'>        <span class="p">([</span><span class="n">_sharedNetworkQueue</span><span class="p">.</span><span class="n">operations</span> <span class="n">count</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>自动调整的队列大小</h3>

<p>继续前面的讨论，我说大多数的网络不允许多于两个的并发网络连接。所以在 3G 网络环境下，你的 queue 的大小应当设置为2。MKNetwork 自动的为你处理这些问题。当网络环境为 3G/EDGE/GPRS,它自动的将当前并发网络连接数调整为2.当切换到wifi网络时，又自动的调整为6.有了这种技术，在 3G 网络下，从远程服务器的图片库中下载缩略图（或者大量相似的请求）将会得到很大的性能提升。</p>

<h3>自动缓存</h3>

<p>MKNetwork能够自动的缓存所有的 &ldquo;GET&rdquo; 请求。当你再次发送相同的请求时，MKNetworkKit 会立即调用请求完成的回调方法，并传送缓存的数据。它也会再次向服务器发送请求。当从远程服务器获取到新的数据，请求完成的回调方法会被再次调用，而这时传送的是最新的数据。因此，你不需要手动的处理缓存。只需要写一行代码，调用一个方法即可，仅此而已。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">MKNetworkEngine</span> <span class="n">sharedEngine</span><span class="p">]</span> <span class="n">useCache</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者，你可以复写 MKNetworkEngine 子类中的方法，自定义缓存的路径和内存中缓存的消耗。</p>

<h3>操作冻结</h3>

<p>使用 MKNetworkKit，你可以冻结网络操作。如果你冻结了一个网络请求操作，当网络连接中断时，它将被自动的加入冻结操作的线性队列中。一旦网络恢复，网络请求将会继续进行。比如微博中的草稿箱功能，就是一个很好的例子。</p>

<p>当你发送了一个微博，并将其网络请求标记为冻结模式，这样 MKNetworkKit 将会自动的处理冻结操作，并为你保存这个请求。这样的微博将会在稍后自动发布，而你不用写一行额外的代码的。这种方式也可以用到其它网络请求中，比如喜欢某个微博，在 Google reader 客户端分享一篇文章，向 Instapaper 中添加一条链接。</p>

<p>对于相似的网络请求，只执行一次</p>

<p>当你加载缩略图（for a twitter stream）时，你最终可能会为每一个缩略图都创建一个网络请求。事实上，你所需要的的请求数和 独立的（unique URLs） 的URL个数是一致的。使用 MKNetworkKit ，在 queue 中的每个 GET 请求，实际上只被执行了一次。MKNetworkKit 还不能做到对“POST”方式的请求进行智能缓存处理。</p>

<h3>图片缓存</h3>

<p>MKNetworkKit 可以完美的实现对图片的缓存处理。通过复写一些方法，你可以设置需要缓存的图片的数量，内存内缓存的负载，以及缓存的路径等。对于这些方法的复写完全是可选的。</p>

<h3>性能</h3>

<p>两个字，速度。MKNetworkKit 进行了无缝的缓存处理。它的处理方式就像NSCache一样，除此之外，当出现内存警告时，内存中的缓存会被转移到磁盘的缓存目录中。</p>

<h3>完全支持ARC</h3>

<p>你通常会为新的项目选择新的网络库。MKNetworkKit 并不是想让你替换掉正在使用的网络库（尽管可以，但是那是一件非常恶心的事儿）。在新的项目中，你总会想着去启用ARC，在写本篇文章的时候，MKNetworkKit 也许是唯一完全支持ARC的网络库。基于 ARC 的内存管理要比 non-ARC（RRC）的内存管理快一个数量级。</p>

<hr />

<h2>如何使用</h2>

<p>好了，不再自我陶醉了，让我们来看看如何使用这个网络库。</p>

<h3>添加 MKNetworkKit 到你的项目中</h3>

<ol>
<li>将 MKNetworkKit 文件拖拽到你的项目中。</li>
<li>添加 CFNetwork.Framework, SystemConfiguration.framework,Security.framework，以及ImageIO.Framework。</li>
<li>将 MKNetworkKit.h 添加到 PCH 文件中</li>
<li>如果你开发的是iOS项目，删除 NSAlert+MKNetworkKitAdditions.h。</li>
<li>如果你开发的是Mac项目，删除 UIAlertView+MKNetworkKitAdditions.h。</li>
</ol>


<p>仅仅需要5个核心文件，一个功能强大的网络库就配置好了。</p>

<h3>MKNetworkKit 中的类</h3>

<ol>
<li>MKNetworkOperation</li>
<li>MKNetworkEngine</li>
<li>其它辅助类(苹果官方用于判断网络是否可连接的类)以及附加类（categories）</li>
</ol>


<p>我推崇简洁易用的原则。苹果已经为开发者完成了繁重的网络连接工作。一个三方库应该做的是，提供一个基于网络的任务队列，并实现可选的缓存功能。我认为所有的三方库都应当不超过10个类文件（无论这个三方库是网络库，或者UIKit的封装库，或者其它任何类型的库。反之，超过10个类文件的库都是臃肿的。 Three 20 是一个臃肿库的例子，ShareKit 也是。也许它们是功能丰富的，但是太大，太臃肿。不像RESTKit那样，ASIHttpRequest 和 AFNetworking 是精悍轻巧的。JSONKit 比 TouchJSON（或者 TouchCode 库中的其它分支类库）轻量级。这也许只是我个人的观点，但是，如果在我的项目中，超过三分之一的代码都来自三方库，那我是无法接受的。</p>

<p>使用臃肿的三方库带来的问题是，我们需要理解它的内部机制，进而进行自定义，使其与自己的需求融合（如果有这个需要的话）。我之前写的一个三方库（ MKStoreKit：帮你添加应用内置购买功能）超轻量级，并且非常容易上手。我相信 MKNetworkKit 也会保持这样的优点。要使用MKNetworkKit，你仅仅需要理解 MKNetworkOperation 和 MKNetworkEngine 这两个类提供的一些共用方法。MKNetworkOperation 类和 ASIHttpRequest 类相似。它是 NSOperation 类的子类，并且进一步封装了所用到的request类和response类。你为你的App中的每一个网络操作创建了一个 MKNetworkOperation 类。</p>

<p>MKNetworkEngine 是一个管理网络队列的&#8221;假&#8221;单例类。由于是假的单例，对于一些简单的请求，你可以直接使用MKNetworkEngine中的方法。在需要更多自定义功能的情况下，应该创建一个它的子类。每一个MKNetworkEngine的子类都有一个属于它自己的用于监测网络连接性的对象，此对象会在网络状态发生变化的时候给它发送通知。你应当为你所使用的每一个独立REST服务器创建一个 MKNetworkEngine 类的子类。由于是伪单例，所以在它的子类中的每一个单独请求都共享一个全局的单一队列。</p>

<p>你可以在 application delegate 中保留一次 MKNetworkEngine 的实例对象，就像对 CoreData 中 managedObjectContext 类一样。在你使用 MKNetworkKit 的时候，你创建了一个 MKnetworkEngine 类的子类去有序的管理网络请求。比如，所以向Yahoo的请求方法定义在一个单独的类中，所有向 Facebook 的请求放在另一个单独的类中。我将展示使用该框架的三个不同的案例。</p>

<h3>示例1：</h3>

<p>我们现在创建一个从雅虎财经栏目拉取数据的“YahooEngine”类</p>

<h4>步骤1：创建一个 YahooEngine 类，并继承 MKNetworkEngine。</h4>

<p>MKNetworkEngine 的初始化方法需要主机名和自定义的协议头部内容（可选）。这些自定义的协议头是可选的，并且可以为空。如果你使用的自己的 REST 服务器（不同于该示例），你可能需要传递 app 的版本，或者其它需要的信息，比如客户端 ID。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">headerFields</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">headerFields</span> <span class="nl">setValue:</span><span class="s">@&quot;iOS&quot;</span> <span class="nl">forKey:</span><span class="s">@&quot;x-client-identifier&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">engine</span> <span class="o">=</span> <span class="p">[[</span><span class="n">YahooEngine</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithHostName:</span><span class="s">@&quot;download.finance.yahoo.com&quot;</span>
</span><span class='line'>                   <span class="nl">customHeaderFields:</span><span class="n">headerFields</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>雅虎有可能没有要求你在协议头中包含 x-client-identifier 字段的值，这个例子只是为了展示这样的功能。</p>

<p>由于使用的是 ARC ，所以是否需要设置对引擎实例对象的强引用关系（strong reference）完全取决于你自己。当你所访问的服务器宕机了，或者由于其它无法预知的因素，你的主机无法访问了，你当前的请求将被自动的添加到冻结请求队列中。对于冻结网络请求的更多信息，请阅读本篇文章中冻结网络操作的部分。</p>

<h4>步骤2：设计引擎类（Separation of concerns）</h4>

<p>让我们现在开始在yahoo Engine 中写用来获取汇率的方法。这些引擎方法将会在你的 view Controller 中调用。一个好的实践经验是，你的引擎类最好不要向调用类暴露URL或者 HTTPHeaders。你的 view 应当不“知道”所需的 URL 端口或者其它参数。也就是说，引擎中的方法的参数应该是货币数量以及货币种类，方法的返回值应该是浮点型的汇率或者获取数据时的时间戳。由于操作是被异步执行的，所以你应该在 blocks 中返回这些值。下面举一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">MKNetworkOperation</span><span class="o">*</span><span class="p">)</span> <span class="nf">currencyRateFor:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span> <span class="n">sourceCurrency</span> <span class="nl">inCurrency:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span> <span class="n">targetCurrency</span> <span class="nl">onCompletion:</span><span class="p">(</span><span class="n">CurrencyResponseBlock</span><span class="p">)</span> <span class="n">completion</span> <span class="nl">onError:</span><span class="p">(</span><span class="n">ErrorBlock</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>父类—— MKNetworkEngine 中定义了如下的三种类型的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">^</span><span class="n">ProgressBlock</span><span class="p">)(</span><span class="kt">double</span> <span class="n">progress</span><span class="p">);</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">^</span><span class="n">ResponseBlock</span><span class="p">)(</span><span class="n">MKNetworkOperation</span><span class="o">*</span> <span class="n">operation</span><span class="p">);</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">^</span><span class="n">ErrorBlock</span><span class="p">)(</span><span class="n">NSError</span><span class="o">*</span> <span class="n">error</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在我们定义的 YahooEngine 中，我们使用一种新的类型的 block，返回汇率值的 CurrencyResponseBlock。定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">^</span><span class="n">CurrencyResponseBlock</span><span class="p">)(</span><span class="kt">double</span> <span class="n">rate</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在一般的App中，你应当使用类似于定义 CurrencyResponseBlock 的方式定义你自己的 block，从而可以在 controller 中获取到需要的数据。</p>

<h4>步骤3：处理数据</h4>

<p>数据处理，说白了就是转换你从服务器获取到的数据，这些数据有可能是 JSON 格式，XML 格式，或者是二进制的 plists。你应当在你的引擎类中进行数据格式的转换。同样，不要让 controller 去完成数据解析的任务。你的引擎类应当返回相应的模块化的数据对象，或者包含模块化对象的数组（数据列表）。在引擎类中将 JSON/XML 格式的数据转换成模块化的数据，考虑到需要降低耦合度，你的 view controller 不应该知道获取 JSON 数据中某个值（value）的键（key）。</p>

<p>上面介绍了如何设计你的自定义引擎类。大多数的网络引擎不要求你降低 controller 和数据处理之前的耦合度，减轻 controller 的负载，但是我要求这样，因为我们在乎你</p>

<h4>步骤4：方法的实现</h4>

<p>我们现在讨论计算汇率的方法的实现细节。</p>

<p>从 yahoo 网站获取货币信息，只需要简单的发送一个GET请求即可。</p>

<p>我写了一个宏定义，通过给定的一对货币单位值来格式化URL。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define YAHOO_URL(__C1__, __C2__) [NSString stringWithFormat:@&quot;d/quotes.csv?e=.csv&amp;amp;f=sl1d1t1&amp;amp;s=%@%@=X&quot;, __C1__, __C2__]</span>
</span></code></pre></td></tr></table></div></figure>


<p>你的引擎类中定义的方法，应当有序的完成下面的任务：</p>

<ol>
<li>根据传递的参数，格式化好所需的 URL</li>
<li>创建一个 MKNetworkOperation 的实例对象用于发送请求</li>
<li>设置 HTTP 请求类型</li>
<li>为创建好的 Operation 添加请求成功和请求失败的回调 block（请求成功的回调 block 中，通常是处理 response 并将其数据进行模块化）</li>
<li>可选，为 operation 添加进度处理（或者在 view controller 中进行请求进度处理）</li>
<li>可选，如果是下载文件的请求，需要为 operation 设置一个下载流（通常是一个文件）</li>
<li>当请求完成的时候，处理请求结果，并将数据返回给调用方法（通常是 controller 中的方法）</li>
</ol>


<p>上代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MKNetworkOperation</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">operationWithPath:</span><span class="n">YAHOO_URL</span><span class="p">(</span><span class="n">sourceCurrency</span><span class="p">,</span> <span class="n">targetCurrency</span><span class="p">)</span> <span class="nl">params:</span><span class="nb">nil</span> <span class="nl">httpMethod:</span><span class="s">@&quot;GET&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">op</span> <span class="nl">onCompletion:</span><span class="o">^</span><span class="p">(</span><span class="n">MKNetworkOperation</span> <span class="o">*</span><span class="n">completedOperation</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>     <span class="n">DLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">completedOperation</span> <span class="n">responseString</span><span class="p">]);</span>
</span><span class='line'>     <span class="c1">// do your processing here</span>
</span><span class='line'>    <span class="n">completionBlock</span><span class="p">(</span><span class="mf">5.0f</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span><span class="nl">onError:</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span><span class="o">*</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">errorBlock</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">enqueueOperation:</span><span class="n">op</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">op</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的实例代码中，格式化了 URL，并且创建了一个 MKNetworkOperation。在分别添加了请求成功和失败的回调 block 之后，它又调用了父类的 equequeOperation 方法，并返回创建好的 MKNetworkOperation 对象的指针。你的 viewcontroller 应当保留保留对该指针的引用关系，当该 viewcontroller 从整个 viewcontroller 体系中移除时，应当取消此次请求操作。因此，如果你在 viewDidAppear 方法中调用了引擎中的方法，应该在 viewWillDisappear 中取消此次请求操作。取消请求操作将会让请求队列去执行其它的网络请求操作（不知道你还记不记得，在移动网络中，仅仅允许两个并发的网络请求，当某个网络请求不再需要时，将其释放掉，能够提升你的 App 的性能和速度）</p>

<p>你的 viewcontroller 也可以（可选）添加请求进度处理，并更新界面。下面的代码实现了进度条的时时更新</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">uploadOperation</span> <span class="nl">onUploadProgressChanged:</span><span class="o">^</span><span class="p">(</span><span class="kt">double</span> <span class="n">progress</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>       <span class="n">DLog</span><span class="p">(</span><span class="s">@&quot;%.2f&quot;</span><span class="p">,</span> <span class="n">progress</span><span class="o">*</span><span class="mf">100.0</span><span class="p">);</span>
</span><span class='line'>       <span class="n">self</span><span class="p">.</span><span class="n">uploadProgessBar</span><span class="p">.</span><span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>MKNetworkEngine 也提供了通过一个 URL 来创建 MKNetworkOperation 对象的便捷方法，本部分前面用于创建 MKNetworkOperation 对象的代码也可以用下面的代码替换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MKNetworkOperation</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">operationWithPath:</span><span class="n">YAHOO_URL</span><span class="p">(</span><span class="n">sourceCurrency</span><span class="p">,</span> <span class="n">targetCurrency</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p>请求URL会被自动的添加相应的前缀域名，这个域名是你在创建引擎类的时候提供的。</p>

<p>创建一个 POST 类型，DELETE 类型，或者 PUT 类型的请求，仅仅需要改变 httpMethod 的参数值即可。MKNetworkEngine 提供了许多这样的便捷方法，你可以在头文件中找到的。</p>

<h3>示例2：</h3>

<p>向服务器传送一张图片（比如发布一条 twit 时附加的图片）</p>

<p>现在让我们来看一个如何向服务器传图片的例子。显然，上传图片的请求必须被编码为 multi-part form 的数据格式。MKNetworkKit 使用和ASIHttpRequest 相似的模型。通过调用 MKNetworkOperation 中的 addFile：forKey：方法，可以添加一个 multi-part form 格式的数据到你的请求中。就是这样简单。</p>

<p>MKNetworkOperation 同时还提供了一个简单的方法，通过 NSData 类型的指针来添加图片。也就是说，你可以调用 addData：forKey：方法来上传图片到远程服务器上。（可以想想从相册里直接上传图片的情形）</p>

<h3>示例3：</h3>

<p>下载图片到本地的目录中（缓存）</p>

<p>使用 MKNetworkKit，从远程服务器下载文件，并保存到本地的操作变的异常容易。</p>

<p>设置 MKNetworkOperation 的 outputStream 即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">operation</span> <span class="nl">setDownloadStream:</span><span class="p">[</span><span class="n">NSOutputStream</span>
</span><span class='line'>    <span class="nl">outputStreamToFileAtPath:</span><span class="s">@&quot;/Users/mugunth/Desktop/DownloadedFile.pdf&quot;</span>
</span><span class='line'>              <span class="nl">append:</span><span class="n">YES</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以设置多个 outputStream 到一个单独的 operation 中，这样可以将相同的文件保存到不同的位置（保存到缓存目录的同时还保存到工作目录中）</p>

<h3>示例4：</h3>

<p>图片缩略图的缓存</p>

<p>为了下载图片，你需要提供一个绝对的 URL 地址，而不是一个路径。MKNetworkEngine 中有一个方便的方法来实现。使用 operationWithURLString:params:httpMethod: 就可以创建一个基于绝地 URL 的 operation。</p>

<p>MKNetworkEngine 是智能的。它将多个基于同一 URL 的 GET 请求合成为一个，在这个请求完成时，通知（回调）所有的 blocks。
这大幅度的提升了下载缩略图的速度。</p>

<p>创建继承于 MKNetworkEngine 的子类，复写相应的方法可以设置缓存的目录和缓存的消耗控制参数。如果你不想自定义这些，你可以直接使用 MKNetworkEngine 方法来下载图片。我建议你自己配置相关的缓存设置。</p>

<h3>缓存操作</h3>

<p>MKNetworkKit 默认会缓存所有的操作。你所要做的是，为你的引擎打开缓存操作。当一个GET类型的请求被执行时，如果对应的response之前被缓存过，缓存的 response 马上会被返回。使用 isCachedResponse 方法可以判断一个 response 是不是缓存过的。下面的代码作了进一步的说明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">op</span> <span class="nl">onCompletion:</span><span class="o">^</span><span class="p">(</span><span class="n">MKNetworkOperation</span> <span class="o">*</span><span class="n">completedOperation</span><span class="p">)</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="k">if</span><span class="p">([</span><span class="n">completedOperation</span> <span class="n">isCachedResponse</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">DLog</span><span class="p">(</span><span class="s">@&quot;Data from cache&quot;</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">DLog</span><span class="p">(</span><span class="s">@&quot;Data from server&quot;</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>     <span class="n">DLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">completedOperation</span> <span class="n">responseString</span><span class="p">]);</span>
</span><span class='line'> <span class="p">}</span><span class="nl">onError:</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span><span class="o">*</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>     <span class="n">errorBlock</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
</span><span class='line'> <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>冻结操作</h3>

<p>可以说，MKNetworkKit 中内置的自动冻结操作的功能是最让人来劲的。只需设置一下就可以使用该功能了，基本上零花费啊！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">op</span> <span class="nl">setFreezable:</span><span class="n">YES</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>网络不可用时，操作被冻结，并被序列化到一个队列中。当网络恢复到可用状态时，冻结的操作继续执行。在 tweeter 中，离线的时候喜欢某个 tweet，等会上线之后，网络操作被自动执行，就是一个很好的例子。</p>

<p>当App进入后台时，冻结的操作会被保存到磁盘中，当app从后台中被唤起之后，冻结的操作也会被自动的执行。</p>

<p>MKNetworkOperation 中方便的方法：</p>

<p>MKNetworkOperation 中提供了如下一些用来格式化网络请求返回数据的便捷方法：</p>

<ol>
<li>responseData</li>
<li>responseString</li>
<li>responseJSON (Only on iOS 5)</li>
<li>responseImage</li>
<li>responseXML</li>
<li>error</li>
</ol>


<p>当网络请求成功后处理 response 时，使用它们会显得非常便捷。如果数据格式不对，这些方法将会返回 nil。比如，使用 responseImage 来返回图片，但是 response 中的数据却是 HTML 格式，这样便会得到一个 nil。唯一一个不会出现错误的方法是r esponseData，使用其它的方法时你必须确保自己知道 response中数据的类型。</p>

<hr />

<h2>方便的宏定义</h2>

<p>DLog 和 ALog 这两个宏定义是我公然从 Stackoverflow 里偷来的，我也忘了是从哪里偷来的了。如果这是你写的话，那就麻烦告诉我一声。</p>

<hr />

<h2>关于GCD的一点说明</h2>

<p>我故意没有使用 GCD，因为网络操作需要随时停止和优化。尽管 GCD 要比 NSOperation 更加高效，但是它无法做这些工作。我不建议你的网络操作使用基于 GCD 的队列。</p>

<hr />

<h2>文档</h2>

<p>所有的头文件中都添加了注释，我尝试使用 apple 的文档风格来加注释。顺便说一句，代码你可以随便用哦。</p>

<hr />

<h2>源代码</h2>

<p>代码在 github 上，并且包含一个 demo</p>

<p><a href="https://github.com/mugunthkumar/mknetworkkit">MKNetworkKit on Github</a></p>

<hr />

<h2>功能建议</h2>

<p>功能建议不要以邮件的方式发给我，最好的方式是<a href="https://github.com/mugunthkumar/mknetworkkit/issues">在github上添加issue</a></p>

<hr />

<h2>许可</h2>

<p>遵循 MIT License</p>

<hr />

<h2>——Mugunth</h2>

<hr />

<h4><em>本文最初写在我的<a href="http://yaongphy.sinaapp.com/?p=531">老博客里面</a>，之前格式太乱。</em></h4>
</div>
  
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-04-02T18:33:20+08:00" pubdate data-updated="true">Apr 2<span>nd</span>, 2014</time>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2014/04/02/using-cocoapods-to-modularize-big-app/">使用 CocoaPods 来模块化一个复杂庞大的 iOS App</a></h1>
    
  </header>


  <div class="entry-content clearfix"><h4>这是一篇对英文技术文章 <a href="http://dev.hubspot.com/blog/architecting-a-large-ios-app-with-cocoapods">Using CocoaPods to Modularize a Big iOS App</a>的简体中文翻译，仅供学习交流。</h4>

<h4>原作者：<a href="http://dev.hubspot.com/blog/author/anthony-roldan">Anthony Roldan</a></h4>

<p>为你的移动 App 选择正确的架构确实是一个大问题。架构会影响你个日常开发流程，决定了你在开发中可能遇到的问题，可以让你变得富可敌国，也可以让你变得穷困潦倒。</p>

<p> HubSpot 的移动端 App 功能非常的丰富。它是一个分析统计 App，也是一个社交媒体 App，还是一个邮件 App，还是一个联系人管理类 App（多对一），所有的这些都同处于一个屋檐下。去年夏天，当我们计划开发这个相当复杂的 App 时，我们知道我们必须有一个与其规模相符合的架构。</p>

<p> 我们最终把每一个 sub-app 当作一个完全独立的 App 来开发，然后用 <a href="http://cocoapods.org/">CocoaPods</a> 来将它们集成到 main App 当中。</p>

<p> 从下面的截图中，你可以看到，Sources, Dashboard, Social Media 这些 sub-app 都是独立的 iPhone App，同时它们又是 main App 中的组成模块。</p>

<p> <img src="http://cdn2.hubspot.net/hub/51294/file-435767237-png/app_example.png?t=1396302307000" alt="哈哈" /></p>

<p>这给我们带来了很多优势：</p>

<ul>
<li>最关键的是，我们能够确定，每个 sub-app 的主分支是稳定可用的，而且 sub-app 的某个特定版本能够很快的被集成到 main app 中。</li>
<li>我们花了更多的时间去 build，花费更少的时间去 merge 。沙盒使得每个 sub-app 内的迭代变得非常容易，而且能使不同 app 之间的集成花费更少的时间。如果你在多于一个人的 iOS 开发团队工作过，你肯定遇到过大量的 .xcodeproj 合并问题。尽管这是<a href="http://stackoverflow.com/questions/2615378/how-to-use-git-properly-with-xcode">可以解决的</a>，但是过程非常的令人痛苦。使用 CocoaPods 来构建应用，几乎让我们完全远离了这种痛苦。</li>
<li>如果需要，我们可以打包部署每个独立的 app ,这对于独立 app 层次的功能测试来说，简直爽爆了。在类似 Navigation 这样的粘合功能没有被完成之前，我们都可以为测试人员提供独立的 app 来测试。这让我们能够收集到高质量，有针对性的反馈。</li>
<li>由于 sub-apps 之间的用户使用流程是通过基于URL的路径(稍后讨论)来实现，这意味着路径是内置的，并且是规划好的。而不是通过检索一大堆 UIViewController 来寻找需要显示的 View 。这对于一些基本功能，比如引导教程和新的推送通知，是非常有帮助的。</li>
</ul>


<p>这种架构方式，对于构建功能丰富多样的 iOS App 的多人协作团队来说，可以节省大量时间。听起来很合你的口味? 那就别停下来。</p>

<hr />

<h3>灵感来自于 Web 架构</h3>

<p>将我们的移动应用分解成多个子应用的灵感，来自于已经非常成功的 HubSpot 的 web 架构。</p>

<p>HubSpot 的 web 架构，专为快速开发和可扩展性而设计。就像我的同事在<a href="http://dev.hubspot.com/blog/how-we-deploy-300-times-a-day">一篇文章中</a>所写的一样，我们使用各种工具和技术，使得我们的整体部署达到300次/每天。最主要的是，HubSpot 的产品系列是由一些松耦合，完全不同功能的应用组成——分析统计，社交媒体，邮件，博客，以及报告工具。</p>

<p>在Web端，我们可以独立地构建、测试、部署 HubSpot 应用中的一小部分。包括后台的 APIs 和 Java 实现的功能，前端的 CoffeeScript 项目，以及 Python 项目。移动端为什么也不这样做呢？</p>

<hr />

<h3>用 CocoaPods 吧</h3>

<p><a href="http://cocoapods.org/">CocoaPods</a>,为iOS而生的极佳依赖管理工具，是将所有东西粘合到一块的关键。</p>

<p>一个多应用架构对于你的需求来说可能是大材小用，但是 CocoaPods 绝对不是这样的。就算你仅仅想添加一些第三方库到项目中时，比如应用统计的库，View 组件，网络库等，它能在短短几分钟的时间内帮你搞定一切设置，节省不少时间。Ruby 风格的语法，能无缝地集成一些第三方库到项目中。</p>

<p>核心的库和可以分享的资源，比如登录，定义了样式的类，访问认证接口，连同 <a href="https://github.com/allending/Kiwi">Kiwi</a> 测试和一个 podspec 文件,构建成一个独立的工程。将其发布到我们的一个私有 <a href="http://guides.cocoapods.org/making/private-cocoapods.html">Repo</a> 中,然后在我们的完整项目中引入。更进一步，每一个子应用连同一个 Podspec 文件单独构建成一个工程之后，用 CocoaPods 将它们构建到一个完整的工程中。</p>

<p>这就意味着，我们可以在一个单独的子应用内部构建测试版本，进行快速的迭代开发，而不用考虑会影响到其它不相关的子应用的开发。</p>

<p>我们整体的应用的 Podfile 应该是这个样子的：</p>

<div><script src='https://gist.github.com/8224121.js'></script>
<noscript><pre><code>platform :ios, &#39;6.0&#39;

# networking, slider navigation, routing
pod &#39;AFNetworking&#39;, &#39;~&gt; 1.2.1&#39;
pod &#39;ViewDeck&#39;, &#39;~&gt; 2.2.11&#39;
pod &#39;JLRoutes&#39;, &#39;~&gt; 1.2&#39;

# sub-apps, pulling from the head of each repo for development. alternately, we can pin it to a release version like we do the other pods
pod &#39;HSAPIClient&#39;, :head
pod &#39;HSCommonResources&#39;, :head
pod &#39;HSMarketingGraderApp&#39;, :head
pod &#39;HSContactsApp&#39;, :head
pod &#39;HSDashboardApp&#39;, :head
pod &#39;HSLoginApp&#39;, :head
pod &#39;HSSocialApp&#39;, :head
pod &#39;HSSourcesApp&#39;, :head
pod &#39;HSSettingsApp&#39;, :head
pod &#39;HSSocialReach&#39;, :head
pod &#39;HSEmailApp&#39;, :head</code></pre></noscript></div>


<hr />

<h3>将所有的东西粘合到一块</h3>

<p>聪明的读者一定注意到了，我们在主应用中使用了很多的第三方开源工具，比如 <a href="https://github.com/Inferis/ViewDeck">IIViewDeck</a> 和 <a href="https://github.com/joeldev/JLRoutes">JLRoutes</a>。这也是将所有的子应用粘合到一块的关键。</p>

<p>我们不需要在主应用中提供每个子应用能够处理的不同menu items 和 routes 信息。每一个子应用提供了一个单独的类，这个类实现了一个 HSBaseApp protocol 和一些方法，如下：</p>

<div><script src='https://gist.github.com/8224163.js'></script>
<noscript><pre><code>@protocol HSBaseApp &lt;NSObject&gt;
+ (UINavigationController *)baseNavigationController;
+ (NSArray *)menuItems;
+ (NSArray *)routesToRegister;
@end</code></pre></noscript></div>


<p>下面给出一个具体的实现例子：</p>

<div><script src='https://gist.github.com/8224273.js'></script>
<noscript><pre><code>+ (UINavigationController *)baseNavigationController {
    return [[HSNavigationController alloc] initWithRootViewController:[[HSSocialViewController alloc] initWithNibName:@&quot;HSSocialViewController&quot; bundle:nil]];
}

+ (NSArray *)menuItems {
    HSMenuItem *calendarMenuItem = [[HSMenuItem alloc] initWithTitle:@&quot;Publishing&quot; icon:@&quot;\\&quot; launchHubSpotApp:[HSSocial class]];
    calendarMenuItem.sectionTitle = @&quot;Social&quot;;
    
    return @[calendarMenuItem];
}

+ (NSArray *)routesToRegister {
    HSRoute *newItemRoute = [HSRoute routeWithUrl:@&quot;social/new&quot; andAction:^BOOL(id&lt;HSRoutingDelegate&gt; routingDelegate, NSString *url, NSDictionary *parameters) {
    //  handle route, usually by suppying a UIViewController to the routingDelegate
    }];

    NSArray *routes = @[newItemRoute]; // could be more routes here too

    return routes;
}</code></pre></noscript></div>


<p>我们使用 routes 来实现可能出现的 push 通知，我们同样使用这种模式来将子应用串到主应用中。比如这样的场景——我们从 Source 或者 Social Media 中跳到 Contact 。</p>

<p>HSRoutingDelegate 在绕过当前活动的 UINavigationController 时，施展了一些小魔法。因此，我们可以根据特定的场景，Push 某个 controller 到屏幕顶层，或者创建一个模型化的 controller 。然而，它只是对 JLRoutes 的漂亮的基于 Block 的语法的简单封装。</p>

<h3>我们还可以做些什么？</h3>

<p>从长远的角度来看，我们想把简单的 Kiwi 测试添加到一些共享的库中，并且构建到 KIF 测试中。这样每一个通过 Kiwi 和 KIF 测试的子应用都可以构建到持续集成环境中。我们可以将当前最好的子应用版本拼合起来构成主应用的发布版本。</p>

<p>你是如果管理多人团队的大型 iOS Apps 的开发的？有没有更好的方式？我们非常期待！</p>

<h4>（本文完）</h4>
</div>
  
  


        </article>
      
      
        <article class="post">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-04-02T10:32:50+08:00" pubdate data-updated="true">Apr 2<span>nd</span>, 2014</time>
        
      </p>
    
    
      <h1 class="entry-title"><a href="/blog/2014/04/02/cocoapods-under-the-hood/">揭开CocoaPods的神秘面纱</a></h1>
    
  </header>


  <div class="entry-content clearfix"><p><strong>本文是 objc 系列文章中 <a href="http://www.objc.io/issue-6/cocoapods-under-the-hood.html">Issue#6 BuildTools &mdash; CocoaPods Under The Hood</a> 的中文简体翻译，仅用于学习交流。原作者是 <a href="https://twitter.com/micheletitolo">Michele Titolo</a></strong></p>

<p>CocoaPods用于管理OSX和iOS应用程序中的第三方库。有了CocoaPods，你就可以自定义一种叫做Pods的依赖文件了，并且可以在不同的时间点和不同的开发环境下轻松的管理他们的版本。</p>

<p>CocoaPods的设计理念包括两个方面。首先，在自己的项目中导入第三方代码时可能会出现不少的“坑”。对于Objective-C的新手开发者来说，配置工程文件是一件很让他们抓狂的事情。在手动配置程序构建阶段的选项和连接器参数的过程中，很容易出现人为的错误。CocoaPods能够自动的配置编译器的各种设置选项，简化了所有的配置工作。</p>

<p>其次，使用CocoaPods可以更加容易的发现新的第三方库。但是，这并不是意味着你可以构建一个叫FrankApp的应用，而应用里的每一部分都是别人代码的简单拼凑。也不是说你可以发现能够缩短开发周期并能提升你的应用程序质量的优质代码库。</p>

<hr />

<h2>核心组件</h2>

<p>CocoaPods 实际上是由一些 Ruby Gems 构成的一个 Ruby 应用程序。探索其内部构成最需要关注的 gems 有：<a href="https://github.com/CocoaPods/CocoaPods/">CocoaPods/CocoaPods</a>, <a href="https://github.com/CocoaPods/Core">CocoaPods/Core</a>, <a href="https://github.com/CocoaPods/Xcodeproj">CocoaPods/XCodeproj</a>（是的，CocoaPods 是由依赖管理工具构建成的依赖管理工具）。</p>

<h3>CocoaPods/CocoaPod</h3>

<p>这是使用者直接调用的一个组件。任何时候，你调用一个 pod 命令，它便处于活动状态。它里面囊括了使用 CocoaPods 时用到的所有功能，充分利用其它 gems 来完成任务。</p>

<h3>CocoaPods/Core</h3>

<p>Core gem 提供了对 CocoaPods 中的一些文件的处理操作，主要是 Podfile 和 podspecs 。</p>

<h4>Podfile</h4>

<p>Podfile 是用来定义你想使用的pods的文件。它是可以高度自定义的，你可以根据具体需求，创建相应的pods文件。更多信息，请查看<a href="http://guides.cocoapods.org/syntax/podfile.html">Podfile guide</a> 。</p>

<h4>Podspec</h4>

<p>*.podspec 文件中定义了将某个具体的 pod 添加到工程中时所需的信息。这些信息包括源文件路径，使用到的官方框架，编译器参数，以及该 pod 所依赖的其它 pod 的细信息，等等。</p>

<h3>CocoaPods/Xcodeproj</h3>

<p>这个 gem 用来处理所有工程文件之间的交互操作。它可以创建并修改 <em>.xcodeproj 和 </em>.xcworkspace 文件。它同样可以作为一个独立的 gem 来使用。如果你想通过脚本来轻松的修改工程文件，它可以帮到你。</p>

<hr />

<h2>运行 pod install 命令</h2>

<p>运行 pod install 命令时，进行了很多的操作。在运行该命令时，附加一个 &ndash; -verbose 参数，可以观察到整个内部的详细执行流程。现在，让我们运行 pod install &mdash;verbose 命令，将会出现下面所示的信息：</p>

<figure class='code'><figcaption><span>通过 pod install - - verbose 命令观察详细执行流程</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>pod install --verbose
</span><span class='line'>
</span><span class='line'>Analyzing dependencies
</span><span class='line'>
</span><span class='line'>Updating spec repositories
</span><span class='line'>Updating spec repo <span class="s1">&#39;master&#39;</span>
</span><span class='line'>  <span class="nv">$ </span>/usr/bin/git pull
</span><span class='line'>  Already up-to-date.
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Finding Podfile changes
</span><span class='line'>  - AFNetworking
</span><span class='line'>  - HockeySDK
</span><span class='line'>
</span><span class='line'>Resolving dependencies of <span class="s1">&#39;Podfile&#39;</span>
</span><span class='line'>Resolving dependencies <span class="k">for </span>target <span class="s1">&#39;Pods&#39;</span> <span class="o">(</span>iOS 6.0<span class="o">)</span>
</span><span class='line'>  - AFNetworking <span class="o">(=</span> 1.2.1<span class="o">)</span>
</span><span class='line'>  - SDWebImage <span class="o">(=</span> 3.2<span class="o">)</span>
</span><span class='line'>    - SDWebImage/Core
</span><span class='line'>
</span><span class='line'>Comparing resolved specification to the sandbox manifest
</span><span class='line'>  - AFNetworking
</span><span class='line'>  - HockeySDK
</span><span class='line'>
</span><span class='line'>Downloading dependencies
</span><span class='line'>
</span><span class='line'>-&gt; Using AFNetworking <span class="o">(</span>1.2.1<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>-&gt; Using HockeySDK <span class="o">(</span>3.0.0<span class="o">)</span>
</span><span class='line'>  - Running pre install hooks
</span><span class='line'>    - HockeySDK
</span><span class='line'>
</span><span class='line'>Generating Pods project
</span><span class='line'>  - Creating Pods project
</span><span class='line'>  - Adding <span class="nb">source </span>files to Pods project
</span><span class='line'>  - Adding frameworks to Pods project
</span><span class='line'>  - Adding libraries to Pods project
</span><span class='line'>  - Adding resources to Pods project
</span><span class='line'>  - Linking headers
</span><span class='line'>  - Installing libraries
</span><span class='line'>    - Installing target <span class="s1">&#39;Pods-AFNetworking&#39;</span> iOS 6.0
</span><span class='line'>      - Adding Build files
</span><span class='line'>      - Adding resource bundles to Pods project
</span><span class='line'>      - Generating public xcconfig file at <span class="s1">&#39;Pods/Pods-AFNetworking.xcconfig&#39;</span>
</span><span class='line'>      - Generating private xcconfig file at <span class="s1">&#39;Pods/Pods-AFNetworking-Private.xcconfig&#39;</span>
</span><span class='line'>      - Generating prefix header at <span class="s1">&#39;Pods/Pods-AFNetworking-prefix.pch&#39;</span>
</span><span class='line'>      - Generating dummy <span class="nb">source </span>file at <span class="s1">&#39;Pods/Pods-AFNetworking-dummy.m&#39;</span>
</span><span class='line'>    - Installing target <span class="s1">&#39;Pods-HockeySDK&#39;</span> iOS 6.0
</span><span class='line'>      - Adding Build files
</span><span class='line'>      - Adding resource bundles to Pods project
</span><span class='line'>      - Generating public xcconfig file at <span class="s1">&#39;Pods/Pods-HockeySDK.xcconfig&#39;</span>
</span><span class='line'>      - Generating private xcconfig file at <span class="s1">&#39;Pods/Pods-HockeySDK-Private.xcconfig&#39;</span>
</span><span class='line'>      - Generating prefix header at <span class="s1">&#39;Pods/Pods-HockeySDK-prefix.pch&#39;</span>
</span><span class='line'>      - Generating dummy <span class="nb">source </span>file at <span class="s1">&#39;Pods/Pods-HockeySDK-dummy.m&#39;</span>
</span><span class='line'>    - Installing target <span class="s1">&#39;Pods&#39;</span> iOS 6.0
</span><span class='line'>      - Generating xcconfig file at <span class="s1">&#39;Pods/Pods.xcconfig&#39;</span>
</span><span class='line'>      - Generating target environment header at <span class="s1">&#39;Pods/Pods-environment.h&#39;</span>
</span><span class='line'>      - Generating copy resources script at <span class="s1">&#39;Pods/Pods-resources.sh&#39;</span>
</span><span class='line'>      - Generating acknowledgements at <span class="s1">&#39;Pods/Pods-acknowledgements.plist&#39;</span>
</span><span class='line'>      - Generating acknowledgements at <span class="s1">&#39;Pods/Pods-acknowledgements.markdown&#39;</span>
</span><span class='line'>      - Generating dummy <span class="nb">source </span>file at <span class="s1">&#39;Pods/Pods-dummy.m&#39;</span>
</span><span class='line'>  - Running post install hooks
</span><span class='line'>  - Writing Xcode project file to <span class="s1">&#39;Pods/Pods.xcodeproj&#39;</span>
</span><span class='line'>  - Writing Lockfile in <span class="s1">&#39;Podfile.lock&#39;</span>
</span><span class='line'>  - Writing Manifest in <span class="s1">&#39;Pods/Manifest.lock&#39;</span>
</span><span class='line'>
</span><span class='line'>Integrating client project
</span></code></pre></td></tr></table></div></figure>


<p>打印出了很多的信息，但是分解之后，整个流程显得清晰明了。下面，让我们来逐一分析。</p>

<h3>读取 Podfile 文件</h3>

<p>如果你曾经感觉到 Podfile 文件中的语法看起来特别古怪，那是因为你正在写的是 Ruby 。相比其它的可用语言，它是一种更加简单的领域特定语言(DSL：Domain Specific Language)。</p>

<p>因此，安装过程中的第一步应当是搞清楚文件中显示地或者隐式地定义了那些 pods 。通过加载 podspecs ，CocoaPods 检索并建立一个包含所有这些 pods 和 它们的版本的列表。Podspecs 被存放在本地的 ~/.cocoapods 目录下。</p>

<h3>版本和冲突</h3>

<p>CocoaPods 使用由 <a href="http://semver.org/">Semantic Versioning</a> 定义的规则来解决依赖库的版本问题。由于这种冲突解决方案可以依赖于补丁版本间的非大量更改，所以可以更加容易的解决依赖问题。比如说，两个不同的 pods 依赖于两个不同版本的 CocoaLumberjack 。如果其中一个依赖于 2.3.1，而另一个依赖于2.3.3版本，解析器会使用最新的2.3.3版本，因为该版本是向后兼容2.3.1版本的。</p>

<p>但是，这并不总是有效。有很多的库不使用这种依赖规则，使得解决版本和冲突问题变得非常困难。</p>

<p>当然，也有很多手动解决冲突的方式。如果一个库依赖于 CocoaLumberjack 的1.2.5 版本，而另一个依赖于 2.3.1，最终的使用者可以通过设置一个确定的版本来解决冲突。</p>

<h3>下载第三方库源代码</h3>

<p>处理过程的下一步是装载依赖库的源代码。每一个 *.podspec 中都包含一个变量，存放 git 远程资源的地址和 tag 标签。这些信息被SHA(Secure Hash Algorithm)算法处理后，存储在 ~/Library/Caches/CocoaPods 目录下。Core gem 负责创建该目录下的文件。</p>

<p>然后，通过使用 Podfile,.podspec,以及 caches 中的信息，将库源码文件下载到 Pods 目录下面。</p>

<h3>生成 Pods.xcodeproj 文件</h3>

<p>每次运行 Pod install 命令时，一旦检测到 *.xcodeproj 文件内容有更改，Xcodeproj gem 将更新其内容。如果该文件不存在， Xcodeproj gem 将按照默认设置创建该文件。否则，将现有的设置信息加载到内存当中。</p>

<h3>安装第三方库</h3>

<p>当 CocoaPods 添加一个库到工程中时，它除了添加库的源代码之外，还添加了很多其它东西。由于每个库的变动都会影响到它自己的 target ，所以对于每一个库，会被添加一些其它的文件。每一个库的源代码需要的附加文件：</p>

<ul>
<li>一个 *.xcconfig 文件，包含工程构建阶段的设置。</li>
<li>一个私有的 *.xcconfig 文件，将上述文件中的设置与 CocoaPods 的默认设置合并。</li>
<li>prefix.pch 文件，构建阶段所需要的。</li>
<li>dummy.m 文件，同样在构建阶段需要。</li>
</ul>


<p>每一个 Pod Target 中都完成这些工作之后，整个的 Pods Target 便被创建了。它同样添加了上述这些文件，同时还添加了一些其它的。如果哪个库源代码包含一个资源 bundle , 添加该 bundle 到 App’target 的说明信息将被添加到 Pods-Rosources.sh 文件中。同样，有一个 Pods-environment.h 文件，可以用其定义的宏来判断某一个组件是否来自某个 pod 。最后，两个声明文件被创建，一个 plist 文件，一个 markdown 文件，用来帮助使用者确认版权信息。</p>

<h3>写入到磁盘中</h3>

<p>到目前为止，很多工作都是用内存中的对象来完成。为了使工作能够重复进行，我们需要一个文件保存所有的配置信息。因而，Pods.xcodeproj 文件，连同其它两个重要的文件  Podfile.lock 和 Manifest.lock，被保存到磁盘中。</p>

<h4>Podfile.lock</h4>

<p>这是 CocoaPods 创建的最重要的文件之一。它追踪所有需要安装的 pods 的现有版本信息。如果你不确定某个已经安装了的 pod 的版本信息，那就查看该文件吧。如果将该文件添加到版本控制工具的资源文件中(<em>译者注：例如，不将该文件添加到.gitignore中</em>)，有利于团队协作开发的一致性，这也是大家推荐的做法。</p>

<h4>Manifest.lock</h4>

<p>这是 Podfile.lock 文件的一个副本，它在你每次运行 pod install 命令时被创建。如果你从来没有看见过这样的错误 <em>sandbox is not in sync with the Podfile.lock</em>，那是因为这个文件不再和 Podfile.lock 完全一样了。由于 Pods 目录并不总是处于版本控制当中，这是一种确保开发者在运行程序前更新 pods 的方式，否则， App 将会崩溃，或者以另外一种不太明显的方式构建失败。</p>

<h4>xcproj</h4>

<p>如果你按照我们推荐的方式，在你的系统中安装了 <a href="https://github.com/0xced/xcproj">xcproj</a>，它会找到 Pods.xcodeproj 文件，并将其转换成旧的 ASCII 格式的 plist 。为什么呢？对这些文件的写操作将不再支持，而过一段时间后，Xcode 仍然依赖于它。如果不安装 xcproj，你的 Pods.xcodeproj 文件将会被保存为一个XML 格式的 plist 文件，当你打开 Xcode 的时候，它将会被重写，导致大量的文件 diffs 。</p>

<hr />

<h2>完成</h2>

<p>成功运行 pod install 命令之后，很多文件被创建，并添加到你的项目中。这个过程仅仅花费了几秒钟的时间。当然，当然，CocoaPods 所完成的工作，没有它，也是可以完成的。但是，这样的话，花费的就不仅仅是几秒钟的时间了。</p>

<hr />

<h2>BTW: <a href="http://en.wikipedia.org/wiki/Continuous_integration">持续集成</a></h2>

<p>CocoaPods 和持续集成并不冲突。对于不同的工程设置，让工程得以成功构建还是相对容易的。</p>

<h3>具有一个版本控制的 Pods 目录</h3>

<p>如果你用版本控制工具来控制 Pods 目录及其中包含的所有文件。你不需要额外做一些特殊处理来完成持续集成。如果你需要指定一个特定的构建方案，选择正确的构建方案来构建 *.xcworkspace 就可以了。</p>

<h3>没有 Pods 目录</h3>

<p>如果你没有使用版本控制工具来控制你的 Pods 目录，你需要做更多的事儿来促使持续集成能够正确的运行。至少，需要对 Podfile 文件进行版本控制。为了易于使用，建议对 .xcworkspace 和 Podfile.lock 文件同样进行版本控制。同样，建议确保被使用的 Pod 的版本是正确的。</p>

<p>一旦你完成了上述的工作，在持续集成环境下运行 CocoaPods 的关键是，确保 pod install 命令在构建(build)工程之前完成。在大多数集成系统中，比如 Jenkins 或者 Travis 中，你仅仅需要将其设置为一个构建步骤(实际上，Travis 将会自动的完成)。Xcode Bots 发布之后，写作此文之际，我们还没有想出一个流畅的处理过程。但是我们正在努力，一旦有所收获，将立即分享给你们。</p>

<hr />

<h2>结束语</h2>

<p>CocoaPods 简化了 Objective-C 的开发，我们的目标是快速发现和利用优质的第三方开源库，并积极参与开源项目的开发。深入理解隐藏在屏幕下面的技术仅仅帮你开发出更好的 apps，我们已经分析了整个执行流程，从加载 specs 和源代码开始，到创建 .xcodeproj 文件及其所有的组件，再到保存所有文件到磁盘中。所以了，下一次使用CocoaPods 时，运行 pod install &mdash; verbose 命令，然后看看有哪些神奇的事情发生了。</p>

<h3>(本文完)</h3>
</div>
  
  


        </article>
      
    </div>

    <ul class="pager">
      
        <li class="previous"><a href="/blog/page/3/">&larr;&nbsp;Older</a></li>
      
      <li><a href="/blog/archives">Blog Archives</a></li>
      
        <li class="next"><a href="/">Newer&nbsp;&rarr;</a></li>
      
    </ul>
  </div>

  
    <aside class="sidebar col-md-3">
      
        <section class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">Recent Posts</h3>
  </div>
  
  <div id="recent_posts" class="list-group">
    
    <a class="list-group-item " href="/blog/2014/05/20/unwind-segues/">Unwind Segues</a>
    
    <a class="list-group-item " href="/blog/2014/05/05/bash-io/">Bash.io.01</a>
    
    <a class="list-group-item " href="/blog/2014/05/01/review-io-me/">review.io.02</a>
    
    <a class="list-group-item " href="/blog/2014/04/29/review-io-me/">review.io.01</a>
    
    <a class="list-group-item " href="/blog/2014/04/22/clone-a-octopress-to-new-places/">在新的环境（电脑）配置已有的 Octopress 博客</a>
    
  </div>
</section>

<section class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">Categories</h3>
    </div>
    <div class="list-group">
        
        
        <a class="list-group-item " href="/blog/categories/test/index.html">
            <span class="badge">1</span>
            test
        </a>
        
        
        <a class="list-group-item " href="/blog/categories/cocoapods/index.html">
            <span class="badge">3</span>
            CocoaPods
        </a>
        
        
        <a class="list-group-item " href="/blog/categories/mknetworkkit/index.html">
            <span class="badge">1</span>
            MKNetworkKit
        </a>
        
        
        <a class="list-group-item " href="/blog/categories/octopress/index.html">
            <span class="badge">1</span>
            Octopress
        </a>
        
        
        <a class="list-group-item " href="/blog/categories/review-io/index.html">
            <span class="badge">2</span>
            review-io
        </a>
        
        
        <a class="list-group-item " href="/blog/categories/bash-io/index.html">
            <span class="badge">1</span>
            Bash-io
        </a>
        
        
        <a class="list-group-item " href="/blog/categories/iostips/index.html">
            <span class="badge">1</span>
            iOSTips
        </a>
        
    </div>
</section>


<section class="panel panel-default clearfix">
  <div class="panel-heading">
      <h3 class="panel-title">GitHub Repos</h3>
  </div>
  <div class="list-group" id="gh_repos">
    <p class="loading">Status updating&#8230;</p>
  </div>
  
    <div class="gh-profile-link pull-right text-muted">
      <a href="https://github.com/yaonphy">@yaonphy</a> on GitHub
    </div>
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'yaonphy',
            count: 3,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">Tag Cloud</h3>
    </div>
    <span id="tag-cloud">
        <embed type='application/x-shockwave-flash' src='/javascripts/tagcloud.swf'width='100%' height='250' bgcolor='#ffffff' id='tagcloudflash' name='tagcloudflash' quality='high' allowscriptaccess='always'flashvars="tcolor=0x333333&amp;tcolor2=0x333333&amp;hicolor=0x000000&amp;tspeed=100&amp;distr=true&amp;mode=tags&amp;tagcloud=%3Ctags%3E%3Ca+href%3D%27http%3A%2F%2Fyaonphy.github.io%2Fblog%2Fcategories%2Fbash-io%27+style%3D%27font-size%3A+23.333333333333336%25%27%3EBash-io%3C%2Fa%3E+%3Ca+href%3D%27http%3A%2F%2Fyaonphy.github.io%2Fblog%2Fcategories%2Fcocoapods%27+style%3D%27font-size%3A+50.0%25%27%3ECocoaPods%3C%2Fa%3E+%3Ca+href%3D%27http%3A%2F%2Fyaonphy.github.io%2Fblog%2Fcategories%2Fiostips%27+style%3D%27font-size%3A+23.333333333333336%25%27%3EiOSTips%3C%2Fa%3E+%3Ca+href%3D%27http%3A%2F%2Fyaonphy.github.io%2Fblog%2Fcategories%2Fmknetworkkit%27+style%3D%27font-size%3A+23.333333333333336%25%27%3EMKNetworkKit%3C%2Fa%3E+%3Ca+href%3D%27http%3A%2F%2Fyaonphy.github.io%2Fblog%2Fcategories%2Foctopress%27+style%3D%27font-size%3A+23.333333333333336%25%27%3EOctopress%3C%2Fa%3E+%3Ca+href%3D%27http%3A%2F%2Fyaonphy.github.io%2Fblog%2Fcategories%2Freview-io%27+style%3D%27font-size%3A+36.66666666666667%25%27%3Ereview-io%3C%2Fa%3E+%3Ca+href%3D%27http%3A%2F%2Fyaonphy.github.io%2Fblog%2Fcategories%2Ftest%27+style%3D%27font-size%3A+23.333333333333336%25%27%3Etest%3C%2Fa%3E+%3C%2Ftags%3E">
    </span>
</section>


<section class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">Sina weibo</h3>
    </div>
    <iframe width="100%" height="480" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=480&fansRow=1&ptype=1&speed=0&skin=5&isTitle=1&noborder=0&isWeibo=1&isFans=0&uid=1851246553&verifier=4e1ba554&dpc=1">
    </iframe>
</section>


<section class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">Earth</h3>
    </div>
    <script type="text/javascript" src="http://jh.revolvermaps.com/2/1.js?i=7k60tywjsze&amp;s=230&amp;m=8&amp;v=false&amp;r=false&amp;b=ffffff&amp;n=false&amp;c=ff0000" async="async"></script>
</section>


      
    </aside>
  
</div>

        </div>
      </div>
    </div>
    <footer role="contentinfo"><div class="container">
    <p class="text-muted credits">
  Copyright &copy; 2014 - yaongfeng<br>
  <small>
      <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>,
<!--      <span class="credit">customized with <a href="https://github.com/kAworu/octostrap3">octostrap3</a></span>. -->
  </small>
</p>

</div>
</footer>
    <script src="/assets/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="/javascripts/modernizr-2.0.js"></script>












  </body>
</html>
